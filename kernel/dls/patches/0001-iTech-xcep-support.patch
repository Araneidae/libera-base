From 4ddce569fd98bbb19f4fe8f88de9604313b0e7db Mon Sep 17 00:00:00 2001
From: Michael Abbott <michael.abbott@diamond.ac.uk>
Date: Wed, 18 Mar 2009 13:42:08 +0000
Subject: [PATCH 1/2] iTech xcep support.

Adds support for the XCEP ARM PXA255 board from IskraTel.  This board
includes an SMSC LAN91C111 network device, together with flash and RAM.
---
 arch/arm/mach-pxa/Kconfig       |    4 +
 arch/arm/mach-pxa/Makefile      |    1 +
 arch/arm/mach-pxa/xcep.c        |  142 ++++++++++++++++++++++++++++++++++++++
 drivers/mtd/maps/Kconfig        |    7 ++
 drivers/mtd/maps/Makefile       |    1 +
 drivers/mtd/maps/xcep.c         |  143 +++++++++++++++++++++++++++++++++++++++
 drivers/net/smc91x.h            |   21 ++++++
 include/asm-arm/arch-pxa/xcep.h |   87 ++++++++++++++++++++++++
 8 files changed, 406 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-pxa/xcep.c
 create mode 100644 drivers/mtd/maps/xcep.c
 create mode 100644 include/asm-arm/arch-pxa/xcep.h

diff --git a/arch/arm/mach-pxa/Kconfig b/arch/arm/mach-pxa/Kconfig
index 5da7a68..2a60846 100644
--- a/arch/arm/mach-pxa/Kconfig
+++ b/arch/arm/mach-pxa/Kconfig
@@ -138,6 +138,10 @@ config MACH_PCM027
 	select PXA27x
 	select IWMMXT
 
+config MACH_XCEP
+	bool "Iskratel Electronics XCEP"
+	select PXA25x
+
 endchoice
 
 choice
diff --git a/arch/arm/mach-pxa/Makefile b/arch/arm/mach-pxa/Makefile
index 0e6d05b..2754a65 100644
--- a/arch/arm/mach-pxa/Makefile
+++ b/arch/arm/mach-pxa/Makefile
@@ -45,6 +45,7 @@ endif
 obj-$(CONFIG_MACH_LITTLETON)	+= littleton.o
 
 obj-$(CONFIG_MACH_ARMCORE)      += cm-x270.o
+obj-$(CONFIG_MACH_XCEP)         += xcep.o
 
 # Support for blinky lights
 led-y := leds.o
diff --git a/arch/arm/mach-pxa/xcep.c b/arch/arm/mach-pxa/xcep.c
new file mode 100644
index 0000000..8b0238f
--- /dev/null
+++ b/arch/arm/mach-pxa/xcep.c
@@ -0,0 +1,142 @@
+/*
+ *  linux/arch/arm/mach-pxa/xcep.c
+ *
+ *  Support for the Iskratel Electronics XCEP platform.
+ *
+ *  Author:     Ales Bardorfer <ales@i-tech.si>
+ *  Updates by: Matej Kenda <matej.kenda@hermes-softlab.com>
+ *  Created:    June 2006
+ *  Copyright:  (C) 2006 Instrumentation Technologies
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/major.h>
+#include <linux/fb.h>
+#include <linux/interrupt.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/i2c.h>
+
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/sizes.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/flash.h>
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/pxa2xx-regs.h>
+#include <asm/arch/pxa2xx-gpio.h>
+#include <asm/arch/xcep.h>
+#include <asm/arch/udc.h>
+#include <asm/arch/irda.h>
+#include <asm/arch/pxafb.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/i2c.h>
+
+#include "generic.h"
+
+
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.name	= "smc91x-regs",
+		.start	= XCEP_ETH_PHYS,
+		.end	= XCEP_ETH_END,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_GPIO(XCEP_ETH_IRQ),
+		.end	= IRQ_GPIO(XCEP_ETH_IRQ),
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.name	= "smc91x-attrib",
+		.start	= 0x0e000000,
+		.end	= 0x0e0fffff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+
+static struct map_desc xcep_io_desc[] __initdata = {
+  	{	/* CPLD */
+		.virtual	= XCEP_CPLD_BASE,
+		.pfn		= __phys_to_pfn(0x10000000),
+		.length		= 0x00000100,
+		.type		= MT_DEVICE
+	}
+};
+
+
+static struct platform_device *devices[] __initdata = {
+	&smc91x_device,
+};
+
+/*
+ * We have to state that there are HWMON devices on the I2C bus on XCEP.
+ * Drivers for HWMON verify capabilities of the adapter when loading and
+ * refuse to attach if the adapter doesn't support HWMON class of devices.
+ * See also Documentation/i2c/porting-clients.
+ */
+static struct i2c_pxa_platform_data xcep_i2c_platform_data  = {
+	.class = I2C_CLASS_HWMON
+};
+
+static void __init xcep_init_vlio(void)
+{
+	/* See Intel XScale Developer's Guide for details */
+	/* Set RDF and RDN to appropriate values (chip select 3 (smc91x)) */
+	MSC1 = (MSC1 & 0xffff) | 0xD5540000;
+
+	/* Set RDF and RDN to appropriate values (chip select 5 (fpga)) */
+	MSC2 = (MSC2 & 0xffff) | 0x72A00000;
+}
+
+static void __init xcep_init(void)
+{
+	xcep_init_vlio();
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+	pxa_set_i2c_info(&xcep_i2c_platform_data);
+}
+
+static void __init xcep_map_io(void)
+{
+	pxa_map_io();
+	iotable_init(xcep_io_desc, ARRAY_SIZE(xcep_io_desc));
+
+	/* This is for the SMC chip select */
+	pxa_gpio_mode(GPIO79_nCS_3_MD);
+
+}
+
+MACHINE_START(XCEP, "Iskratel XCEP")
+	.phys_io	   = 0x80000000,
+	.io_pg_offst       = 0xf8000000,
+	.boot_params       = 0xa0000100,
+	.map_io		   = xcep_map_io,
+	.init_irq	   = pxa25x_init_irq,
+	.timer		   = &pxa_timer,
+	.init_machine      = xcep_init,
+MACHINE_END
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index 17bc87a..a815b90 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -166,6 +166,13 @@ config MTD_PXA2XX
 	help
 	  This provides a driver for the NOR flash attached to a PXA2xx chip.
 
+config MTD_XCEP
+	tristate "CFI Flash device mapped on Iskratel XCEP"
+	depends on MACH_XCEP && MTD_CFI && MTD_PARTITIONS
+	help
+	  This provides a driver for the on-board flash of the Iskratel
+	  XCEP board.
+
 config MTD_OCTAGON
 	tristate "JEDEC Flash device mapped on Octagon 5066 SBC"
 	depends on X86 && MTD_JEDEC && MTD_COMPLEX_MAPPINGS
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 957fb5f..e3f47cb 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -21,6 +21,7 @@ obj-$(CONFIG_MTD_ICHXROM)	+= ichxrom.o
 obj-$(CONFIG_MTD_CK804XROM)	+= ck804xrom.o
 obj-$(CONFIG_MTD_TSUNAMI)	+= tsunami_flash.o
 obj-$(CONFIG_MTD_PXA2XX)	+= pxa2xx-flash.o
+obj-$(CONFIG_MTD_XCEP)		+= xcep.o
 obj-$(CONFIG_MTD_MBX860)	+= mbx860.o
 obj-$(CONFIG_MTD_CEIVA)		+= ceiva.o
 obj-$(CONFIG_MTD_OCTAGON)	+= octagon-5066.o
diff --git a/drivers/mtd/maps/xcep.c b/drivers/mtd/maps/xcep.c
new file mode 100644
index 0000000..e72cdc8
--- /dev/null
+++ b/drivers/mtd/maps/xcep.c
@@ -0,0 +1,143 @@
+/*
+ * $Id$
+ *
+ * Map driver for the Iskratel XCEP platform.
+ *
+ * Author:      Ales Bardorfer <ales@i-tech.si>
+ * Created:     July 2006
+ * Copyright:	 (C) 2006 Instrumentation Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+
+#include <linux/dma-mapping.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/pxa2xx-regs.h>
+#include <asm/arch/pxa2xx-gpio.h>
+#include <asm/arch/xcep.h>
+
+
+#define WINDOW_ADDR 0x00000000
+#define WINDOW_SIZE 32*1024*1024
+
+
+# if 0 // TODO: Can we use DMA on XCEP flash?
+static void xcep_map_inval_cache(struct map_info *map, unsigned long from, ssize_t len)
+{
+	consistent_sync((char *)map->cached + from, len, DMA_FROM_DEVICE);
+}
+#endif 
+
+static struct map_info xcep_map = {
+	.name =     "XCEP flash",
+	.size =		WINDOW_SIZE,
+	.phys =		WINDOW_ADDR,
+	// .inval_cache = 	xcep_map_inval_cache,
+};
+
+
+static struct mtd_partition xcep_partitions[] = {
+	{
+		.name =		"Bootloader",
+		.size =		0x00040000,
+		.offset =	0,
+//		.mask_flags =	MTD_WRITEABLE  /* force read-only */
+	},{
+		.name =		"Bootloader ENV",
+		.size =		0x00040000,
+		.offset =	0x00040000,
+//		.mask_flags =	MTD_WRITEABLE  /* force read-only */
+	},{
+		.name =		"Kernel",
+		.size =		0x00100000,
+		.offset =	0x00080000,
+	},{
+		.name =		"Rescue fs",
+		.size =		0x00280000,
+		.offset =	0x00180000,
+	},{
+		.name =		"Filesystem",
+		.size =		MTDPART_SIZ_FULL,
+		.offset =	0x00400000
+	}
+};
+
+
+static struct mtd_info *xcep_mtd;
+static struct mtd_partition *parsed_parts = NULL;
+static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
+
+static int __init init_xcep(void)
+{
+	static int nr_parsed_parts = 0;
+	int ret = 0;
+
+	xcep_map.bankwidth = (BOOT_DEF & 1) ? 2 : 4;
+	xcep_map.virt = ioremap(xcep_map.phys, WINDOW_SIZE);
+	if (!xcep_map.virt) {
+		printk(KERN_WARNING "Failed to ioremap %s\n", xcep_map.name);
+		return -ENOMEM;
+	}
+
+	xcep_map.cached = ioremap_cached(xcep_map.phys, WINDOW_SIZE);
+	if (!xcep_map.cached)
+		printk(KERN_WARNING "Failed to ioremap cached %s\n", xcep_map.name);
+	simple_map_init(&xcep_map);
+	
+	printk(KERN_NOTICE "Probing %s at physical address 0x%08lx (%d-bit bankwidth)\n",
+		   xcep_map.name, xcep_map.phys,
+		   xcep_map.bankwidth * 8);
+	
+	xcep_mtd = do_map_probe("cfi_probe", &xcep_map);
+	if (!xcep_mtd) {
+		iounmap((void *)xcep_map.virt);
+		if (xcep_map.cached)
+			iounmap(xcep_map.cached);
+		return -EIO;
+	}
+	xcep_mtd->owner = THIS_MODULE;
+	
+	ret = parse_mtd_partitions(xcep_mtd, probes, &parsed_parts, 0);
+	if (ret > 0) {
+		add_mtd_partitions(xcep_mtd, parsed_parts, ret);
+	} else {
+		printk("Using static partitions on %s\n", xcep_map.name);
+		add_mtd_partitions(xcep_mtd, xcep_partitions, ARRAY_SIZE(xcep_partitions));
+	}
+	return 0;
+}
+
+static void __exit cleanup_xcep(void)
+{
+	if (xcep_mtd) {
+		del_mtd_partitions(xcep_mtd);
+		map_destroy(xcep_mtd);
+		iounmap((void *)xcep_map.virt);
+		if (xcep_map.cached)
+			iounmap(xcep_map.cached);
+	}
+
+	if (parsed_parts)
+		kfree(parsed_parts);
+}
+
+module_init(init_xcep);
+module_exit(cleanup_xcep);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ales Bardorfer <ales@i-tech.si>");
+MODULE_DESCRIPTION("MTD map driver for Iskratel XCEP");
diff --git a/drivers/net/smc91x.h b/drivers/net/smc91x.h
index 8606818..67d7ff9 100644
--- a/drivers/net/smc91x.h
+++ b/drivers/net/smc91x.h
@@ -429,6 +429,27 @@ static inline void LPD7_SMC_outsw (unsigned char* a, int r,
 
 #include <asm/unit/smc91111.h>
 
+#elif defined(CONFIG_MACH_XCEP)
+
+#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_16BIT	1
+#define SMC_CAN_USE_32BIT	1
+#define SMC_NOWAIT		1
+#define SMC_USE_PXA_DMA		1
+
+#define SMC_inb(a, r)		readb((a) + (r))
+#define SMC_inw(a, r)		readw((a) + (r))
+#define SMC_inl(a, r)		readl((a) + (r))
+#define SMC_outb(v, a, r)	writeb(v, (a) + (r))
+#define SMC_outw(v, a, r)	writew(v, (a) + (r))
+#define SMC_outl(v, a, r)	writel(v, (a) + (r))
+#define SMC_insl(a, r, p, l)	readsl((a) + (r), p, l)
+#define SMC_outsl(a, r, p, l)	writesl((a) + (r), p, l)
+
+#define RPC_LSA_DEFAULT		RPC_LED_100_10
+#define RPC_LSB_DEFAULT		RPC_LED_TX_RX
+
+
 #else
 
 /*
diff --git a/include/asm-arm/arch-pxa/xcep.h b/include/asm-arm/arch-pxa/xcep.h
new file mode 100644
index 0000000..f5fda0c
--- /dev/null
+++ b/include/asm-arm/arch-pxa/xcep.h
@@ -0,0 +1,87 @@
+/*
+ * linux/include/asm-arm/arch-pxa/xcep.h
+ *
+ * Created 2002/01/10 by Boris Stuhec <boriss@hermes.si>
+ * XCEP customizations by Ales Bardorfer <ales@i-tech.si>
+ *
+ * This file contains the hardware specific definitions for XCEP
+ * Only include this file from SA1100-specific files.
+ *
+ * 
+ */
+#ifndef __ASM_ARCH_XCEP_H
+#define __ASM_ARCH_XCEP_H
+
+#define XCEP_ETH_PHYS	0x0c000300
+#define XCEP_ETH_END    0x0c0fffff
+#define XCEP_ETH_IRQ	0
+
+/*  XCEP CPLD base */
+#define XCEP_CPLD_BASE  0xf0000000
+
+/* CPLD serial select register base */
+#define XCEP_CPLD_SS_BASE XCEP_CPLD_BASE+0x02
+
+/* CPLD serial select register */
+#define XCEP_CPLD_SS (*(volatile unsigned char *)(XCEP_CPLD_SS_BASE))
+#define EVB_ENABLE       (1<<2)
+#define SS1              (1<<1)
+#define SS0              (1<<0)
+
+/* FPGA EVB base */
+#define EVB_FPGA_BASE  0xf1000000
+
+/* FPGA PCMCIA control register base   */
+#define EVB_FPGA_PCCR_BASE  EVB_FPGA_BASE+0xa
+
+/* FPGA PCMCIA status register base   */
+#define EVB_FPGA_PCSR_BASE  EVB_FPGA_BASE+0xc
+
+/* FPGA serial control register base   */
+#define EVB_FPGA_SCR_BASE  EVB_FPGA_BASE+0x12
+
+/* FPGA serial control register */
+#define EVB_FPGA_SCR (*(volatile unsigned short *)(EVB_FPGA_SCR_BASE)) 
+#define CEP_IRDA_MD1	 (1<<2)
+#define CEP_IRDA_MD0	 (1<<1)
+#define CEP_IRDA_FIR_SEL (1<<0)
+
+
+#ifdef CONFIG_SA1100_CEP
+extern void CEP_IRDA_control (unsigned int mask, unsigned int val);
+#else
+#define CEP_IRDA_control(m,s)	do { } while (0)
+#endif
+
+#define CEP_IRDA_set(x)	   CEP_IRDA_control((x), (x))
+#define CEP_IRDA_clear(x)  CEP_IRDA_control((x), 0)
+
+
+/* PCMCIA interface
+ *
+ * Registers
+ * PCSR		Status Register
+ * PCCR		Control Register
+ *
+ */
+#define CEP_GPIO_IRQ		GPIO_GPIO (4)	
+#define CEP_GPIO_CD		GPIO_GPIO (3)	
+#define CEP_IRQ_GPIO_IRQ	IRQ_GPIO4	
+#define CEP_IRQ_GPIO_CD		IRQ_GPIO3 
+#define CEP_BVD1		(1<<4)
+#define CEP_BVD2		(1<<5)
+#define CEP_VS1			(1<<2)
+#define CEP_VS2			(1<<3)
+#define PCMCIA_RESET		(1<<7)
+#define VPPEN1			(1<<12)
+#define VPPEN0			(1<<11)
+#define VCCEN0			(1<<9)
+#define VCCEN1			(1<<10)
+#define nCD			(1<<0)
+#define READY			(1<<1)
+#define INPACK			(1<<2)
+#define RESET_ENABLE		(1<<8)
+#define EVB_FPGA_PCSR (*(volatile unsigned char *)(EVB_FPGA_PCSR_BASE))
+#define EVB_FPGA_PCCR (*(volatile unsigned short *)(EVB_FPGA_PCCR_BASE))	
+#define EVB_FPGA_PCCR_H (*(volatile unsigned char *)(EVB_FPGA_PCCR_H_BASE))
+#endif
-- 
1.6.1.3

