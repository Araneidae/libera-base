#!/bin/sh

# Script to update u-boot on Libera

HERE="$(dirname "$0")"
U_BOOT_IMAGE="$HERE/u-boot.bin"


Error()
{
    echo >&2 "$@"
    exit 1
}

# Compares image in memory with given file (length of 0x40000 is assumed)
#
#   check_mem <start-address> <file>
#
check_mem()
{
    "$ARCH"/readmem $1 0x40000 |
    "$ARCH"/bindiff "$2"  &&
    # This last line is a bit absurd.  With Libera 1.46 bash (version 2.05b)
    # we don't have `set -o pipefail` available, so need to check readmem
    # separately.
    [ $PIPESTATUS = 0 ]
}

# Writes to mtd device using method appropriate to target system.
#
#   write_mtd <file> <mtd-number>
#
write_mtd()
{
    if [ -b /dev/mtdblock$2 ]; then
        cat "$1" >/dev/mtdblock$2
    else
        flashcp "$1" /dev/mtd$2
    fi
}


[ "$(uname -m)" = armv5tel ]  ||
    Error This should be run on Libera

# Determine which target architecture: ARM ABI or EABI.  Do this by checking
# which loader is installed.
case $(echo /lib/ld-linux.so.*) in
    /lib/ld-linux.so.2)     ARCH="$HERE"/linux-arm ;;
    /lib/ld-linux.so.3)     ARCH="$HERE"/linux-arm_el ;;
    *)  Error 'Do not recognise the architecture.  Wrong target system?'
esac



VERBOSE=false
TIMEOUT=5
# DEFAULT_SERVER_ADDRESS=172.23.240.3
DEFAULT_SERVER_ADDRESS=172.23.194.1
FORCED=false

# Read default serverip from configuration if possible.
SERVER_ADDRESS="$(
    cat /dev/mtd1 |
    "$ARCH"/readenv |
    sed -n '/^serverip=/{s///;p;q;}')"
[ -z "$SERVER_ADDRESS" ]  &&  SERVER_ADDRESS=$DEFAULT_SERVER_ADDRESS


ECHO=:
TEST=false
UPGRADE=true
while getopts 'hvt:s:fT' option; do
    case "$option" in
    h)  cat <<'EOF'
Usage: update-u-boot [options]
    -h      Show this help
    -v      Verbose mode: comment on every stage
    -t:     Set boot timeout
    -s:     Set tftp server address
    -f      Force update even if u-boot up to date (testing only!)
    -T      Test whether update needed, but don't update.
EOF
        exit 0 ;;
    v)  VERBOSE=true
        ECHO=echo ;;
    t)  TIMEOUT="$OPTARG" ;;
    s)  SERVER_ADDRESS="$OPTARG" ;;
    f)  FORCED=true ;;
    T)  TEST=true
        UPGRADE=false ;;
    *)  Error Invalid option: try -h for help ;;
    esac
done
    

if ! $FORCED || $TEST; then
    $ECHO Testing if u-boot already upgraded
    if "$ARCH"/bindiff $($VERBOSE || echo -q) /dev/mtd0 "$U_BOOT_IMAGE"; then
        $ECHO U-boot already upgraded
        $FORCED || exit 0
    elif $TEST; then
        echo U-boot needs upgrade
        # If we're in verbose and test mode then drop through to calculate the
        # new environment
        $VERBOSE || exit 1
    fi
fi


NEW_ENV=/tmp/mtd1.new


IP_ADDRESS=$(
    /sbin/ifconfig eth0 |
    sed -n '/^eth0/{n;s/^.*inet addr://;s/ .*$//;p;}')
NET_MASK=$(
    /sbin/ifconfig eth0 |
    sed -n '/^eth0/{n;s/^.*Mask://;s/ .*$//;p;}')
GATEWAY=$(
    route -n |
    sed -n '/^0\.0\.0\.0  */{s///;s/  *.*$//;p;q;}')

BOOT_ARGS="$(cat /proc/cmdline)"

{
    cat <<EOF 
baudrate=115200
bootargs=$BOOT_ARGS
bootcmd=bootm 80000
bootdelay=$TIMEOUT
ipaddr=$IP_ADDRESS
netmask=$NET_MASK
serverip=$SERVER_ADDRESS
stdin=serial
stderr=serial
stdout=serial
EOF
    [ -n "$GATEWAY" ]  &&  echo "gatewayip=$GATEWAY"
} |
"$ARCH"/makeenv 40000 4000 > $NEW_ENV  ||
    Error Error preparing new u-boot environment

if $VERBOSE; then
    echo New u-boot environment:
    cat $NEW_ENV | "$ARCH"/readenv
fi
$TEST  &&  exit 1


$ECHO Updating u-boot environment.

if [ "$(uname -r)" = "2.4.21-rmk1-pxa1-z" ]; then
    $ECHO Enabling write to u-boot mtd
    insmod "$HERE"/mtd-rw.ko
    trap on_exit 'rmmod mtd-rw.ko'
fi

$ECHO Writing updated environment
write_mtd $NEW_ENV 1  &&
sync  &&
$ECHO Checking new u-boot environment  &&
check_mem 0x40000 $NEW_ENV  ||
    Error Failed to write new u-boot environment


# Ok.  We've done everything we need to do; now it's time to update the
# u-boot itself.  If this goes wrong we're in trouble!
$ECHO Writing new u-boot
write_mtd "$U_BOOT_IMAGE" 0  &&
sync  &&
check_mem 0 "$U_BOOT_IMAGE"  ||
{
    echo >&2 $'\e[1;31m' !!!WARNING!!!  
    echo >&2 !!!
    echo >&2 !!! u-boot on machine $(hostname) is unbootable.
    echo >&2 !!! $'\e[1;0m'
    exit 1
}
